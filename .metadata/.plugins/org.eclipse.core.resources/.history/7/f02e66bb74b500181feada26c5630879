/*
 * PruebaMatrices.cpp
 *
 *  Created on: Sep 10, 2018
 *      Author: pablo
 */

#include "PruebaMatrices.h"

template<class T> PruebaMatrices::PruebaMatrices(pablo::matrix<T> matriz) {

	if(matriz.size1() != matriz.size2())
		throw std::invalid_argument("No es cuadrada");
	else{
		std::size_t n = matriz.size1();
		pablo::matrix<T> matrizL(n,n);
		pablo::matrix<T> matrizU(n,n);
		llenarMatriz(matriz);
		imprimirMatriz(matriz);
		unpack(matriz, matrizL, matrizU);
		imprimirMatriz(matrizL);
		imprimirMatriz(matrizU);

	}

}

template<class T> void PruebaMatrices::imprimirMatriz(pablo::matrix<T>& matriz){

	std::cout << "Imprimir matriz" << std::endl;

	for(std::size_t i = 0 ; i < matriz.size1(); i++){
		for (std::size_t j = 0 ; j < matriz.size1() ; j++){
			if (j == matriz.size1() - 1)
				std::cout << matriz(i,j) << std::endl;
			else
				std::cout << matriz(i,j) << " ";
		}
	}
}

template<class T> void PruebaMatrices::llenarMatriz(pablo::matrix<T>& matriz){

	for (std::size_t i = 0 ; i < matriz.size1(); i++){

		for (std::size_t j = 0 ; j < matriz.size1(); j++){

			matriz(i,j) = T(rand() % 9 + 1);

		}

	}

}

template<class T> void PruebaMatrices::unpack(pablo::matrix<T>& matrizADescomponer, pablo::matrix<T>& matrizL, pablo::matrix<T>& matrizU){

	std::cout << "Descomponer la matriz" << std::endl;

		for(std::size_t i = 0 ; i < matrizADescomponer.size1(); i++){
				for (std::size_t j = 0 ; j < matrizADescomponer.size1() ; j++){
					if(i > j)
						matrizL(i,j) = matrizADescomponer(i,j);
					else
						matrizU(i,j) = matrizADescomponer(i,j);
				}
			}

}

template<class T> void PruebaMatrices::doolitle(pablo::matrix<T>& matrizInicial, pablo::matrix<T>& matrizLU, std::vector<T> vectorDePermutacion){



}

PruebaMatrices::~PruebaMatrices() {

}

int main() {

	pablo::matrix<int> matriz1 (4,4);
	matriz1(0,0) = 2;
	matriz(0,1) = 8;
	matriz(0,2) = 1;
	matriz(0,3) = 8;
	PruebaMatrices *prueba = new PruebaMatrices(matriz1);

	return 0;

}
